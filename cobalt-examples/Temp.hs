-- do not edit; automatically generated by UU.AG
module Temp where

import TempImport
-- Expr --------------------------------------------------------
{-
   inherited attributes:
      gamma                : Gamma

   chained attributes:
      unique               : Int

   synthesised attributes:
      cset                 : [Constraint]
      tp                   : Type

-}
{-
   local variables for Expr.Apply:
      freshVar0

-}
{-
   local variables for Expr.Lambda:
      freshVar1
      freshVar0

-}
{-
   local variables for Expr.Let:
      freshVar1
      freshVar0

-}
{-
   local variables for Expr.Variable:
      freshVar0

-}
{-
   local variables for Expr.Where:
      freshVar1
      freshVar0

-}
data Expr = Apply (Expr) (Expr)
          | Lambda (Identifier) (Expr)
          | Let (Identifier) (Expr) (Expr)
          | Variable (Identifier)
          | Where (Expr) (Identifier) (Expr)
-- semantic domain
type T_Expr = (Gamma) ->
              (Int) ->
              ( ([Constraint]),(Type),(Int))
-- cata
sem_Expr :: (Expr) ->
            (T_Expr)
sem_Expr ((Apply (_function) (_argument))) =
    (sem_Expr_Apply ((sem_Expr (_function))) ((sem_Expr (_argument))))
sem_Expr ((Lambda (_ident) (_body))) =
    (sem_Expr_Lambda (_ident) ((sem_Expr (_body))))
sem_Expr ((Let (_ident) (_decl) (_body))) =
    (sem_Expr_Let (_ident) ((sem_Expr (_decl))) ((sem_Expr (_body))))
sem_Expr ((Variable (_ident))) =
    (sem_Expr_Variable (_ident))
sem_Expr ((Where (_body) (_ident) (_definition))) =
    (sem_Expr_Where ((sem_Expr (_body))) (_ident) ((sem_Expr (_definition))))
sem_Expr_Apply :: (T_Expr) ->
                  (T_Expr) ->
                  (T_Expr)
sem_Expr_Apply (function_) (argument_) =
    \ _lhsIgamma
      _lhsIunique ->
        let _lhsOcset :: ([Constraint])
            _lhsOtp :: (Type)
            _lhsOunique :: (Int)
            _functionIcset :: ([Constraint])
            _functionItp :: (Type)
            _functionIunique :: (Int)
            _functionOgamma :: (Gamma)
            _functionOunique :: (Int)
            _argumentIcset :: ([Constraint])
            _argumentItp :: (Type)
            _argumentIunique :: (Int)
            _argumentOgamma :: (Gamma)
            _argumentOunique :: (Int)
            ( _functionIcset,_functionItp,_functionIunique) =
                (function_ (_functionOgamma) (_functionOunique))
            ( _argumentIcset,_argumentItp,_argumentIunique) =
                (argument_ (_argumentOgamma) (_argumentOunique))
            -- "Temp.ag"(line 43, column 4)
            (_freshVar0@_) =
                makeFresh (_lhsIunique + 0) :: Type
            -- "Temp.ag"(line 42, column 4)
            (_functionOunique@_) =
                _lhsIunique + 1
            -- "Temp.ag"(line 41, column 4)
            (_argumentOgamma@_) =
                _lhsIgamma
            -- "Temp.ag"(line 40, column 4)
            (_functionOgamma@_) =
                _lhsIgamma
            -- "Temp.ag"(line 39, column 4)
            (_lhsOtp@_) =
                _freshVar0
            -- "Temp.ag"(line 38, column 4)
            (_lhsOcset@_) =
                _functionIcset ++ _argumentIcset ++ [eqc (_functionItp) (arrow (_argumentItp) (_freshVar0)) ("Inconsistent types in application")]
            -- copy rule (up)
            (_lhsOunique@_) =
                _argumentIunique
            -- copy rule (chain)
            (_argumentOunique@_) =
                _functionIunique
        in  ( _lhsOcset,_lhsOtp,_lhsOunique)
sem_Expr_Lambda :: (Identifier) ->
                   (T_Expr) ->
                   (T_Expr)
sem_Expr_Lambda (ident_) (body_) =
    \ _lhsIgamma
      _lhsIunique ->
        let _lhsOcset :: ([Constraint])
            _lhsOtp :: (Type)
            _lhsOunique :: (Int)
            _bodyIcset :: ([Constraint])
            _bodyItp :: (Type)
            _bodyIunique :: (Int)
            _bodyOgamma :: (Gamma)
            _bodyOunique :: (Int)
            ( _bodyIcset,_bodyItp,_bodyIunique) =
                (body_ (_bodyOgamma) (_bodyOunique))
            -- "Temp.ag"(line 51, column 4)
            (_freshVar1@_) =
                makeFresh (_lhsIunique + 1) :: Type
            -- "Temp.ag"(line 50, column 4)
            (_freshVar0@_) =
                makeFresh (_lhsIunique + 0) :: Type
            -- "Temp.ag"(line 49, column 4)
            (_bodyOunique@_) =
                _lhsIunique + 2
            -- "Temp.ag"(line 48, column 4)
            (_bodyOgamma@_) =
                update (ident_) (_freshVar0) (_lhsIgamma)
            -- "Temp.ag"(line 47, column 4)
            (_lhsOtp@_) =
                _freshVar1
            -- "Temp.ag"(line 46, column 4)
            (_lhsOcset@_) =
                _bodyIcset ++ [eqc (_freshVar1) (arrow (_freshVar0) (_bodyItp)) ("Inconsistent types in lambda abstraction")]
            -- copy rule (up)
            (_lhsOunique@_) =
                _bodyIunique
        in  ( _lhsOcset,_lhsOtp,_lhsOunique)
sem_Expr_Let :: (Identifier) ->
                (T_Expr) ->
                (T_Expr) ->
                (T_Expr)
sem_Expr_Let (ident_) (decl_) (body_) =
    \ _lhsIgamma
      _lhsIunique ->
        let _lhsOcset :: ([Constraint])
            _lhsOtp :: (Type)
            _lhsOunique :: (Int)
            _declIcset :: ([Constraint])
            _declItp :: (Type)
            _declIunique :: (Int)
            _declOgamma :: (Gamma)
            _declOunique :: (Int)
            _bodyIcset :: ([Constraint])
            _bodyItp :: (Type)
            _bodyIunique :: (Int)
            _bodyOgamma :: (Gamma)
            _bodyOunique :: (Int)
            ( _declIcset,_declItp,_declIunique) =
                (decl_ (_declOgamma) (_declOunique))
            ( _bodyIcset,_bodyItp,_bodyIunique) =
                (body_ (_bodyOgamma) (_bodyOunique))
            -- "Temp.ag"(line 60, column 4)
            (_freshVar1@_) =
                makeFresh (_lhsIunique + 1) :: Type
            -- "Temp.ag"(line 59, column 4)
            (_freshVar0@_) =
                makeFresh (_lhsIunique + 0) :: SVar
            -- "Temp.ag"(line 58, column 4)
            (_declOunique@_) =
                _lhsIunique + 2
            -- "Temp.ag"(line 57, column 4)
            (_bodyOgamma@_) =
                update (ident_) (_freshVar0) (_lhsIgamma)
            -- "Temp.ag"(line 56, column 4)
            (_declOgamma@_) =
                _lhsIgamma
            -- "Temp.ag"(line 55, column 4)
            (_lhsOtp@_) =
                _freshVar1
            -- "Temp.ag"(line 54, column 4)
            (_lhsOcset@_) =
                _declIcset ++ _bodyIcset ++ [genc (_freshVar0) (_lhsIgamma) (_declItp) ("Generalize failed in Let"), eqc (_bodyItp) (_freshVar1) ("Type of body does not match context type for Let")]
            -- copy rule (up)
            (_lhsOunique@_) =
                _bodyIunique
            -- copy rule (chain)
            (_bodyOunique@_) =
                _declIunique
        in  ( _lhsOcset,_lhsOtp,_lhsOunique)
sem_Expr_Variable :: (Identifier) ->
                     (T_Expr)
sem_Expr_Variable (ident_) =
    \ _lhsIgamma
      _lhsIunique ->
        let _lhsOcset :: ([Constraint])
            _lhsOtp :: (Type)
            _lhsOunique :: (Int)
            -- "Temp.ag"(line 35, column 4)
            (_freshVar0@_) =
                makeFresh (_lhsIunique + 0) :: Type
            -- "Temp.ag"(line 34, column 4)
            (_lhsOunique@_) =
                _lhsIunique + 1
            -- "Temp.ag"(line 33, column 4)
            (_lhsOtp@_) =
                _freshVar0
            -- "Temp.ag"(line 32, column 4)
            (_lhsOcset@_) =
                [instc (_freshVar0) (mylookup (ident_) (_lhsIgamma)) ("Should not fail")]
        in  ( _lhsOcset,_lhsOtp,_lhsOunique)
sem_Expr_Where :: (T_Expr) ->
                  (Identifier) ->
                  (T_Expr) ->
                  (T_Expr)
sem_Expr_Where (body_) (ident_) (definition_) =
    \ _lhsIgamma
      _lhsIunique ->
        let _lhsOcset :: ([Constraint])
            _lhsOtp :: (Type)
            _lhsOunique :: (Int)
            _bodyIcset :: ([Constraint])
            _bodyItp :: (Type)
            _bodyIunique :: (Int)
            _bodyOgamma :: (Gamma)
            _bodyOunique :: (Int)
            _definitionIcset :: ([Constraint])
            _definitionItp :: (Type)
            _definitionIunique :: (Int)
            _definitionOgamma :: (Gamma)
            _definitionOunique :: (Int)
            ( _bodyIcset,_bodyItp,_bodyIunique) =
                (body_ (_bodyOgamma) (_bodyOunique))
            ( _definitionIcset,_definitionItp,_definitionIunique) =
                (definition_ (_definitionOgamma) (_definitionOunique))
            -- "Temp.ag"(line 69, column 4)
            (_freshVar1@_) =
                makeFresh (_lhsIunique + 1) :: Type
            -- "Temp.ag"(line 68, column 4)
            (_freshVar0@_) =
                makeFresh (_lhsIunique + 0) :: SVar
            -- "Temp.ag"(line 67, column 4)
            (_bodyOunique@_) =
                _lhsIunique + 2
            -- "Temp.ag"(line 66, column 4)
            (_bodyOgamma@_) =
                update (ident_) (_freshVar0) (_lhsIgamma)
            -- "Temp.ag"(line 65, column 4)
            (_definitionOgamma@_) =
                _lhsIgamma
            -- "Temp.ag"(line 64, column 4)
            (_lhsOtp@_) =
                _freshVar1
            -- "Temp.ag"(line 63, column 4)
            (_lhsOcset@_) =
                _bodyIcset ++ _definitionIcset ++ [genc (_freshVar0) (_lhsIgamma) (_definitionItp) ("Generalize failed in Where"), eqc (_bodyItp) (_freshVar1) ("Type of body does not match type of Where")]
            -- copy rule (up)
            (_lhsOunique@_) =
                _definitionIunique
            -- copy rule (chain)
            (_definitionOunique@_) =
                _bodyIunique
        in  ( _lhsOcset,_lhsOtp,_lhsOunique)


