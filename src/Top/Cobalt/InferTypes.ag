imports {
import Top.Constraint.Equality
import Top.Constraint.Polymorphism
import Top.Solver.Greedy
import Top.Solver
import Top.Constraint.Information
import Top.Constraint
import Top.Implementation.Overloading
import Top.Implementation.Basic (ErrorLabel)
import Debug.Trace
}

ATTR TypeRules TypeRule [ | | typeErrors USE { ++ } { [] } : TypeErrors ]
ATTR TypeSystem -> TypeRule [ classEnvironment:ClassEnvironment | | ]

ATTR DeductionRule Judgements Judgement ConstraintTerms ConstraintTerm Terms Term 
   [ strmap : {[(String, Int)]} | unique : Int | cset USE { ++ } { [] } : CSet ]
             
SEM TypeRule
  | TypeRule 
       loc.strmap = zip @nubVars [0..]
       deduction.unique = length @nubVars
       loc.nubVars = nub (@deduction.allVariables ++ @constraints.allVariables)
       loc.cset = [ SumLeft $ Equality tp (TCon "Constraint") "(Constraint)"
                  | tp <- @constraints.tps 
                  ] ++ 
                  @deduction.cset ++ @constraints.cset
       loc.solveResult = runGreedy @lhs.classEnvironment noOrderedTypeSynonyms @constraints.unique @cset 
                            :: SolveResult String Predicates ()
       loc.sub = substitutionFromResult @solveResult
       lhs.typeErrors = errorsFromResult @solveResult


              
SEM Judgement
  | Judgement
       lhs.cset = [ SumLeft $ Equality inh (TCon "Gamma") "(Gamma)" | inh <- @inhs.tps ]
                  ++ [SumLeft $ Equality @expression.tp (TCon "Expr") "(Expr)"] ++
                  [ SumLeft $ Equality syn (TCon "Type") "(Type)" | syn <- @syns.tps ]
                  ++ 
                  @inhs.cset ++ @expression.cset ++ @syns.cset

ATTR ConstraintTerms [ | | tps : Tps]

SEM ConstraintTerms
  | Cons   lhs.tps = @hd.tp : @tl.tps
  | Nil    lhs.tps = []

ATTR ConstraintTerm [ | | tp : Tp]

SEM ConstraintTerm 
  | ConstraintTerm lhs.tp = @constraint.tp
	
ATTR Terms [ | | tps : Tps ]

SEM Terms
  | Cons   lhs.tps = @hd.tp : @tl.tps
  | Nil    lhs.tps = []

ATTR Term  [ | | tp : Tp ]

SEM Term
  | TermVar    lhs.tp = TVar (@variable ? @lhs.strmap)
  | TermString lhs.tp	= TCon "String"
  | TermApp    lhs.tp = TVar @lhs.unique
               lhs.cset = (SumRight $ Instantiate
                             (foldr (.->.) (TVar @lhs.unique) @arguments.tps)
                             (SigmaScheme $ lookupWithDefaultFM @lhs.functions (error "unknown function") @function) 
                             ("apply " ++ @function ++ " in " ++ @lhs.rulename))
                              : @arguments.cset
               arguments.unique = @lhs.unique + 1

{
type TypeErrors = [TypeError]
type TypeError  = (CInfo, ErrorLabel)
type CSet  = [MyCon]
type MyCon = ConstraintSum EqualityConstraint (PolymorphismConstraint Predicates) CInfo
type CInfo = String
instance TypeConstraintInfo CInfo
instance PolyTypeConstraintInfo Predicates CInfo

}
