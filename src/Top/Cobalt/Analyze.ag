-- Maybe convert everything to FiniteMaps and combine these instead of combining lists and converting
-- afterwards.
-- Every premise consists of a meta var which has a judgement associated with it through its type.
-- Later we might want to allow arbitrary predicates here. On the other hand, why not lists these in the constraints?
-- Analysis of the type rules only takes place if there are no errors in the agdatas and judgementdecls.
-- There are cases where we could proceed, but for now we don't.
-- We obtain the types that are allowed in judgement declarations from the functions
-- that are passed to it. This includes the types and used constructed in the DATA section.

SEM TypeSystem 
  | TypeSystem
       lhs.staticErrors = @errorsAfterWhichTyperulesAreSkipped ++
                          @dupRuleName ++
                          if null @errorsAfterWhichTyperulesAreSkipped then @typerules.staticErrors else []
       typerules.agdatas       = @agDATAs.self
       loc.allfunctions        = @lhs.functions `plusFM` listToFM @agDATAs.altTypes
       typerules.functions     = @allfunctions      
       judgementdecls.types    = nub (concat (map (constantsInType . unqualify . unquantify) (values @allfunctions)))
       typerules.altArgTypesMap   = listToFM @agDATAs.altArgTypes
       typerules.judgementsMap = listToFM (joinAL @agDATAs.altNts @judgementdecls.judgements)
       typerules.nts           = @agnts
       loc.alternatives   = nub (domainAL @agDATAs.altNts)
       loc.agnts          = nub (rangeAL @agDATAs.altNts)
       loc.judgementsnts  = nub (domainAL @judgementdecls.judgements)
       loc.dupRuleName    = [ DuplicateRuleName x | x <- duplicates @typerules.rulenames ]
       loc.dupAlternative = [ DuplicateAlternative x | x <- duplicates @alternatives ]
       loc.ntNotDefined = [ NonTerminalNotDefined nt 
                          | nt <- @judgementsnts
                          , not (nt `elem` @agnts)
                          ]
       loc.ntMissesJudgement = [ MissesJudgement nt 
                               | nt <- @agnts
                               , not (nt `elem` @judgementsnts)
                               ]
       loc.errorsAfterWhichTyperulesAreSkipped = 
           @ntNotDefined ++ @ntMissesJudgement ++ @dupAlternative ++ @judgementdecls.staticErrors
       
       
SEM AGData
  | AGData   lhs.altTypes = [(@alternative, toTpScheme @altTp )]
             lhs.altArgTypes = [(@alternative, map snd @children)]
             lhs.altNts  = [(@alternative, @nonterminal)] 
             loc.altTp = foldr (.->.) (TCon @nonterminal) (map (TCon . snd) @children)

SEM JudgementDecl
  | JudgementDecl lhs.staticErrors = [ UnknownType @datatype tp
                                     | tp <- @inhs ++ @syns 
                                     , tp `notElem` @lhs.types
                                     ] 
                  lhs.judgements = [(@datatype, (@inhs, @syns))]
  

SEM TypeRule
  | TypeRule
       lhs.rulenames = [@rulename]
       deduction.rulename   = @rulename
       constraints.rulename = @rulename

SEM ConstraintTerm
  | ConstraintTerm
       -- We check that each constraint is an application.
       -- That the application results in a constraint is done during type inference.
       lhs.staticErrors = 
          [ ConstraintIsNotApplication @lhs.rulename (getTerm con)
          | con <- [@self]
          , not (isTermApp con)
          ] 
          ++ @constraint.staticErrors

-- Skip check of premises when conclusion is not correct to avoid cascade of errors.
SEM DeductionRule
  | DeductionRule
       conclusion.isConclusion = True
       conclusion.metaVarAL   = []
       premises.isConclusion   = False
       
       (loc.staticErrorsConclusion, loc.conclusionAttr, loc.conclusionMetaVarAL) = 
         case (checkConclusion @lhs.rulename @lhs.judgementsMap @lhs.altArgTypesMap @lhs.nts @conclusion.self) of
           Escape errors           -> (errors, Nothing, [])
           Continue conclusionAttr -> ([], Just conclusionAttr, metaVarAL conclusionAttr)

       premises.metaVarAL = @conclusionMetaVarAL
       loc.usedVars = nub (@premises.usedVars ++ @conclusion.usedVars)
       lhs.usedVars = @usedVars
       loc.declaredVars = @premises.declaredVars ++ @conclusion.declaredVars
       lhs.conclusionAttr = @conclusionAttr
       
       lhs.staticWarnings = 
          @conclusion.staticWarnings ++ @premises.staticWarnings ++
          [ MetaVarNotUsed @lhs.rulename x
          | x <- map snd @conclusionMetaVarAL
          , x `notElem` @usedVars
          ] ++
          [ DeclaredAndUsedInPremise @lhs.rulename x -- only variables declared below may be used above the line
          | x <- @premises.usedVars
          , x `elem` @premises.declaredVars
          ]
       lhs.staticErrors = 
          @staticErrorsConclusion ++
          [ DuplicateVar @lhs.rulename x     -- every implictly declared variable should be unique.
          | x <- duplicates @declaredVars
          ] ++
          case @conclusionAttr of
             Nothing -> [] -- Skip the premises
             Just _  -> 
               let metaVarsPremise = map preMeta (catMaybes @premises.premiseAttrs)
               in @premises.staticErrors ++
                 [ DuplicateMetaVarInPremise @lhs.rulename x     -- every (used) metavar in the premise must be unique
                 | x <- duplicates metaVarsPremise
                 ] ++
                 [ DuplicateVar @lhs.rulename x     -- every declared var must be unique
                 | x <- duplicates @declaredVars
                 ]
                       
SEM Judgement 
  | Judgement
       lhs.staticErrors = @inhs.staticErrors ++ @expression.staticErrors ++ @newErrors ++ @syns.staticErrors
       (lhs.premiseAttrs, loc.newErrors) = 
          if @lhs.isConclusion then ([], []) 
          else 
            case (checkPremise @lhs.rulename @lhs.judgementsMap @lhs.metaVarAL @self) of
              Escape errors        -> ([Nothing], errors)
              Continue premiseAttr -> ([Just premiseAttr], [])
       lhs.usedVars = if @lhs.isConclusion then @syns.allVariables else @inhs.allVariables ++ @expression.allVariables
       lhs.declaredVars = if @lhs.isConclusion then @inhs.allVariables ++ @expression.allVariables else @syns.allVariables
       
SEM Term
  | TermVar   
       lhs.allVariables = [@variable]	 
  | TermApp
       lhs.staticErrors = 
          [ FunctionNotDefined @lhs.rulename @function 
          | @function `notElem` keysFM @lhs.functions 
          ] ++
          @arguments.staticErrors

{
type StaticMessages = [StaticMessage]
data StaticMessage = FunctionNotDefined         String{-rulename-} String
                   | UnknownType                String{-nt-}       String
                   | MetaVarNotDefined          String{-rulename-} String              
                   | DuplicateMetaVarInPremise  String{-rulename-} String
                   | DuplicateVar               String{-rulename-} String
                   | DuplicateRuleName          String{-rulename-}
                   | ConstraintIsNotApplication String{-rulename-} Term
                   | MustBeVar                  String{-rulename-} Term
                   | MustBeSimpleApp            String{-rulename-} Term  
                   | NonTerminalNotDefined      String     -- if a judgement is given for a non-existent nonterminal
                   | MissesJudgement            String{-nt-}
                   | NoJudgementForType         String{-rulename-} String{-type-}
                   | DuplicateAlternative       String
                   | UnknownAlternative         String{-rulename-} String
                   | WrongNumberOfArguments     String{-rulename-} Term
                   | WrongNumberOfAttributes    String{-rulename-} String{-where-}
                   | InternalError              String{-rulename-} String{-what happened-}
                   
                   | DeclaredAndUsedInPremise   String{-rulename-} String
                   | MetaVarNotUsed             String{-rulename-} String
     deriving Show

type PremiseAttrs   = [Maybe PremiseAttr]
data PremiseAttr    = PremiseAttr 
   { preMeta           :: String 
   , preMetaType       :: String
   , preSynVars        :: [Term]  -- implicitly declared variables from the synthesized section
   , preInhExprs       :: [Term]  -- all inherited expressions
--   , declaredInPremise :: [String] -- Variables declared by this construct: the syns in this case
   }
   
data ConclusionAttr = ConclusionAttr
   { conAlternative       :: String     -- name of the alternative
   , metaVarAL            :: VarAL      -- maps each metavar (that has a type referring to an AG datatype) to its type
   , conInhVars           :: [Term]     -- implicitly declared variables from the inherited attr section
   , conSynExprs          :: [Term]     -- all synthesized expressions
--   , declaredInConclusion :: [String] -- Variables declared by this construct: the inhs and the meta vars in this case
   }


checkPremise :: String -> JudgementsMap -> VarAL -> Judgement -> Escape StaticMessages PremiseAttr
checkPremise rulename judgementdeclmap metavarAL (Judgement inhExprs expr synExprs) = 
   do{ var <- check (matchTermVar expr) [MustBeVar rulename expr]
     ; tp <- check (lookup var metavarAL) [MetaVarNotDefined rulename var]
     ; (inhTypes, synTypes) <- 
         check (lookupFM judgementdeclmap var) [NoJudgementForType rulename tp]  -- retrieve info on judgement for this type
     ; let synVars = filter (isJust . matchTermVar) synExprs
     ; continueIf (length inhTypes == length inhExprs) [WrongNumberOfAttributes rulename ("premise " ++ var ++", inhs")] +++
       continueIf (length synTypes == length synExprs) [WrongNumberOfAttributes rulename ("premise " ++ var ++ ", syns")] +++
       continueIf (length synVars == length synExprs) (map (MustBeVar rulename) (filter (not . isJust . matchTermVar) syns))
     ; return (PremiseAttr var tp synVars)
     }

checkConclusion :: String -> JudgementsMap -> AltArgTypesMap -> [String] -> Judgement -> Escape StaticMessages ConclusionAttr 
checkConclusion rulename judgementdeclmap argtypesmap nts (Judgement inhExprs expr synExprs) =
   do{ (con, args) <- check (matchSimpleTermApp expr) [MustBeSimpleApp rulename expr]                -- is expr of the form C var1 ... varm ?
     ; (inhTypes, synTypes) <- 
         check (lookupFM judgementdeclmap con) [UnknownAlternative rulename con]                                               -- is C known?
     ; argTypes <- check (lookupFM argtypesmap con) [InternalError rulename "while doing lookup for argument type of conclusion"]
                                                                                                                       -- Should not go wrong
     ; let inhVars = filter (isJust . matchTermVar) inhExprs
     ; continueIf (length inhTypes == length inhExprs) [WrongNumberOfAttributes rulename "conclusion, inhs"] +++  -- Compare declared and given number of inherited attributes
       continueIf (length synTypes == length synExprs) [WrongNumberOfAttributes rulename "conclusion, syns"] +++  -- Compare declared and given number of synthesized attributes
       continueIf (length args == length argTypes) [WrongNumberOfArguments rulename expr] +++  -- Compare declared and given number of arguments to C
       continueIf (length inhVars == length inhExprs) (map (MustBeVar rulename) (filter (not . isJust . matchTermVar) inhExprs)) -- All inhs should be simple variables.
     ; return (ConclusionAttr con (metaFilter nts (zip args argTypes)) inhExprs synExprs)
     }

-- Helper functions

metaFilter :: [String] -> [(String,String)] -> [(String,String)] 
metaFilter metatypes = filter (\(var,tp) -> tp `elem` metatypes)

getTerm :: ConstraintTerm -> Term
getTerm (ConstraintTerm term) = term

isTermVar :: ConstraintTerm -> Bool
isTermVar = isJust . matchTermVar . getTerm

isTermApp :: ConstraintTerm -> Bool
isTermApp = isJust . matchTermApp . getTerm 

isSimpleTermApp :: ConstraintTerm -> Bool
isSimpleTermApp = isJust . matchSimpleTermApp . getTerm

matchTermVar :: Term -> Maybe String
matchTermVar (TermVar x) = Just x
matchTermVar _           = Nothing

matchTermApp :: Term -> Maybe String
matchTermApp (TermApp fun args) = Just fun
matchTermApp _                  = Nothing

matchSimpleTermApp :: Term -> Maybe (String, [String])
matchSimpleTermApp (TermApp fun args) = do xs <- mapM matchTermVar args ; return (fun, xs)
matchSimpleTermApp _                  = Nothing

getTermVariables :: Term -> [String]
getTermVariables (TermVar x)        = [x]
getTermVariables (TermApp fun args) = concat (map getTermVariables args)
getTermVariables (TermString s)     = []

-- Bastiaan
values = eltsFM

}
